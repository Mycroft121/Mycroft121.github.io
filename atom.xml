<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-11T15:50:03.634Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ChenCheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4.11笔记</title>
    <link href="http://yoursite.com/2016/04/11/4-11%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/11/4-11笔记/</id>
    <published>2016-04-11T15:36:15.000Z</published>
    <updated>2016-04-11T15:50:03.634Z</updated>
    
    <content type="html">&lt;p&gt;window.onload = function(){&lt;br&gt;            var oDiv1 = document.getElementById(‘div1’);&lt;br&gt;            var oDiv2 = document.getElementById(‘div2’);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    addClass(oDiv1,&amp;apos;box&amp;apos;);
    removeClass(oDiv2,&amp;apos;box1&amp;apos;);

    function addClass(obj,className){
        //如果原来没有class
        if(obj.className==&amp;apos;&amp;apos;){
            obj.className = className;
        }else{
        //如果原本有calss
            //如果要添加的class在原来的class中不存在
            var arrClassName = obj.className.split(&amp;apos; &amp;apos;);
            var _index = arrIndexOf(arrClassName,className);
            //obj.className += &amp;apos; &amp;apos;+ className;
            if (_index ==-1) {
                //如果添加的class在原来的class中存在
                obj.className += &amp;apos; &amp;apos;+className;
            }                        
                //如果要添加的class在原来的class中存在
        }
    }

    function removeClass(obj,className){
        //如果原来有class
        if(obj.class !=&amp;apos;&amp;apos;){
            var arrClassName = obj.className.split(&amp;apos; &amp;apos;);
            var _index = arrIndexOf(arrClassName,className);
            //如果有我们要移除的class
            if (_index != -1) {
                arrClassName.splice(_index,1);
                obj.className = arrClassName.join(&amp;apos; &amp;apos;);
            }
        }
        //如果原来没有class
    }    

    function arrIndexOf(arr, v){
        for(var i = 0;i&amp;lt; arr.length;i++){
            if (arr[i] == v) {
                return i;
            }
        }
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;/&lt;em&gt;&lt;br&gt;        thead    :  表格头&lt;br&gt;        tBodies    :  表格正文&lt;br&gt;        tFoot    :  表格尾&lt;br&gt;            rows    :  行&lt;br&gt;            rows    :  列
&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;//onchange：当值发生改变的时候触发&lt;br&gt;            /&lt;em&gt;&lt;br&gt;                text : 当光标移开的时候，内容有变化就会触发&lt;br&gt;                radio/checkbox : 标准下点击的时候只要值变了就会触发&lt;br&gt;                        非标准下是离开的时候如果值变了就会触发
            &lt;/em&gt;/&lt;/p&gt;
</content>
    
    <summary type="html">
    
      4.11笔记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.10笔记</title>
    <link href="http://yoursite.com/2016/04/11/4-10%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/11/4-10笔记/</id>
    <published>2016-04-10T18:15:21.000Z</published>
    <updated>2016-04-10T18:18:48.416Z</updated>
    
    <content type="html">&lt;p&gt;var name = ‘value’;&lt;br&gt;    //oText.name;有问题&lt;br&gt;    //oText[name];OK&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
    元素.getAttribute(属性名称);方法 获取指定元素的指定属性的值
*/
//alert(oText.getAttribute(&amp;apos;value&amp;apos;));
/*
    元素.setAttribute(属性名称，属性值);方法 给指定元素指定的属性设置值
*/
//oText.setAttribute(&amp;apos;value&amp;apos;,&amp;apos;HELLO&amp;apos;);
/*
    元素.removeAttribute(属性名称);方法 移除指定的元素的指定的属性
*/
//oText.removeAttribute(&amp;apos;value&amp;apos;);
/*
    1.用.和[]的形式无法操作元素的自定义属性
    getAttribute可以操作元素的自定义属性
*/
//alert(oText._name_);
alert(oText.getAttribute(&amp;apos;_name_&amp;apos;));

var oImg = document.getElementById(img1);
/*
    2.可以获取元素属性实际的值
*/
//alert(oImg.src);
//alert(oImg[src]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;document.createElement(标签名称);创建元素&lt;br&gt;父级.removeChild(要删除的元素); 删除元素&lt;br&gt;//添加到页面中&lt;br&gt;    /&lt;em&gt;&lt;br&gt;        父级.appendChild(要添加的元素) 方法 追加子元素
    &lt;/em&gt;/&lt;br&gt;    //oUl.appendChild(oLi);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
    父级.insertBefore(新的元素，被插入的元素)方法 在指定的元素前面插入一个新元素
    在ie下如果第二个参数的节点不存在，会报错
    在其他标准浏览器下如果第二个参数的节点不存在，则会以appenChild的形添加式进行
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;父级.replaceChild(新节点，被替换节点) 替换子节点&lt;/p&gt;
&lt;p&gt;appendChild,insertBefore,replaceChild都可以操作动态创建出来的节点，也可以操作已有节点&lt;/p&gt;
</content>
    
    <summary type="html">
    
      4.10笔记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.9笔记</title>
    <link href="http://yoursite.com/2016/04/09/4-9%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/09/4-9笔记/</id>
    <published>2016-04-09T13:21:28.000Z</published>
    <updated>2016-04-09T15:30:48.336Z</updated>
    
    <content type="html">&lt;p&gt;offsetLeft[Top]:只读 属性 当前元素到定位父级的（偏移值）&lt;br&gt;        到当前元素的offsetParent的距离&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果没有定位父级
    offsetParent -&amp;gt; body
    offsetLeft -&amp;gt;html

如果有定位父级
    ie7以下:如果自己没有定位，那么offsetLeft[Top]是到body的距离
            如果自己有定位，那么就是到定位父级的距离
    其他:到定位父级的距离
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;width height&lt;br&gt;    style.width：样式宽&lt;br&gt;    clientWidth：可视区宽&lt;br&gt;    offsetWidth：占位宽&lt;br&gt;alert(oDiv.style.width);&lt;br&gt;alert(oDiv.clientWidth);//样式宽+padding 120&lt;br&gt;alert(oDiv.offsetWidth);//样式宽+padding+border 可视区宽+边框 122&lt;/p&gt;
</content>
    
    <summary type="html">
    
      4.9笔记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.8笔记</title>
    <link href="http://yoursite.com/2016/04/09/4-8%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/09/4-8笔记/</id>
    <published>2016-04-09T13:13:41.000Z</published>
    <updated>2016-04-09T13:16:32.823Z</updated>
    
    <content type="html">&lt;p&gt;元素.firstChild :只读 属性 第一个子节点&lt;br&gt;        标准下：firstChild会包含文本类型的节点&lt;br&gt;        非标准下：只包含元素类型的节点&lt;br&gt;元素.firstElementChild: 只读 属性 标准下获取第一个元素类型的子节点&lt;br&gt;parentNode:只读 属性 当前节点的父级节点&lt;br&gt;parentNode:父节点&lt;br&gt;元素.offsetParent:只读 属性 有定位的父节点&lt;br&gt;        如果没有定位父级，默认是body&lt;br&gt;        ie7以下,如果当前元素没有定位默认是body，如果有定位则是html&lt;br&gt;        ie7以下,如果当前元素的某个父级触发了layout，那么OffsetParent就会被指向到这个触发了layout特性的父节点上&lt;/p&gt;
</content>
    
    <summary type="html">
    
      4.8笔记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.7笔记</title>
    <link href="http://yoursite.com/2016/04/07/4-7%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/07/4-7笔记/</id>
    <published>2016-04-07T15:23:46.000Z</published>
    <updated>2016-04-07T15:25:43.194Z</updated>
    
    <content type="html">&lt;p&gt;DOM:Document Object Model文档对象模型&lt;br&gt;            文档:html页面&lt;br&gt;            文档对象:页面中元素&lt;br&gt;            文档对象模型:定义 为了能够让程序(js)去操作页面中的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DOM会把文档看作一颗树,同时定义了很多方法来操作这棵树中的每一个元素(节点)
DOM节点
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;元素.childNodes:只读 属性 子节点列表集合&lt;br&gt;                    标准下：包含了文本和元素类型的节点,但也会包含非法嵌套的子节点&lt;br&gt;                    非标准下：只包含元素类型的节点，ie7以下不会包含非法嵌套子节点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    childNodes只包含一级子节点，不包含后辈孙级以下的节点

DOM节点的类型有很多种 12种

元素.nodeType:只读 属性 当前元素的节点类型

元素节点:  1
文本节点:  3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;元素.children :只读 属性 子节点列表集合&lt;br&gt;                    标准下：只包含元素类型的节点&lt;br&gt;                    非标准下：只包含元素类型的节点&lt;/p&gt;
</content>
    
    <summary type="html">
    
      4.7笔记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.6笔记</title>
    <link href="http://yoursite.com/2016/04/06/4-6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/06/4-6笔记/</id>
    <published>2016-04-06T12:44:41.000Z</published>
    <updated>2016-04-06T14:52:59.034Z</updated>
    
    <content type="html">&lt;p&gt;var str = “妙味课堂”;&lt;br&gt;str.charCodeAt()所选字符串的字母编码&lt;br&gt;String.fromCharCode(22937)根据编码转换成字符串&lt;br&gt;str.indexOf(‘m’，i)查找数组中m所在位置，i表示从第i位开始查找。返回值为-1，表示没找到&lt;br&gt;str.lastindexOf()表示从右往左找//如果第二个值为负值，默认当成0来处理&lt;br&gt;str.substring(0,2)//截取前两个字符串&lt;br&gt;str.substring(2,0)//截取两个字符串，大的往后扔，小的往前扔；或者如果为负数的话，表示为0&lt;br&gt;str.slice(2,0)//不交换位置，只会从左往左右找，这样什么都找不到&lt;br&gt;str.slice(-2)//跳到尾部第二位开始从左往右找&lt;br&gt;str.slice(-4,-2)&lt;br&gt;str.toUpperCase()//全部转换为大写&lt;br&gt;str.toLowerCase()//全部转换为小写&lt;br&gt;str.split(‘.’);//根据点划分，成为一个数组&lt;br&gt;var str = leo;&lt;br&gt;str.split(‘’);//直接划分成[‘l’,’e’,’o’]&lt;br&gt;split还有个可选参数，表示分割的长度&lt;/p&gt;
</content>
    
    <summary type="html">
    
      4.6笔记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.5笔记</title>
    <link href="http://yoursite.com/2016/04/05/4-5%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/05/4-5笔记/</id>
    <published>2016-04-05T15:16:14.000Z</published>
    <updated>2016-04-05T15:18:04.395Z</updated>
    
    <content type="html">&lt;p&gt;作为调整，早休息。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      空白
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.4笔记</title>
    <link href="http://yoursite.com/2016/04/05/4-4%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/05/4-4笔记/</id>
    <published>2016-04-05T15:10:48.000Z</published>
    <updated>2016-04-05T15:12:57.281Z</updated>
    
    <content type="html">&lt;p&gt;这一个 月的总结，活的太累，没有规律，想的太多做的太少，其实做软件这个东西对于经验还是更加重要一些，多做练习。多看书多学习吧。少玩游戏早点休息。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      日记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.3笔记</title>
    <link href="http://yoursite.com/2016/04/03/4-3%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/03/4-3笔记/</id>
    <published>2016-04-03T13:30:40.000Z</published>
    <updated>2016-04-03T13:38:46.797Z</updated>
    
    <content type="html">&lt;p&gt;先写出主要功能，然后放进函数里，吧可变的提取出来，用参数替代。&lt;br&gt;遇到正负的参数，可以采用if语句判断&lt;br&gt;if（endFn）{&lt;br&gt;  endFn（）;&lt;br&gt;};&lt;br&gt;等价于endFn&amp;amp;&amp;amp;endFn();如果前面为真，就执行后面一个函数；&lt;br&gt;上述代码是用来用函数回调的。&lt;br&gt;function getStyle ( obj, attr ) { return obj.currentStyle?obj.currentStyle[attr] : getComputedStyle( obj )[attr]; }&lt;br&gt;上面函数用来获取style里的数值&lt;/p&gt;
</content>
    
    <summary type="html">
    
      函数封装
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.2笔记</title>
    <link href="http://yoursite.com/2016/04/02/4-2%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/02/4-2笔记/</id>
    <published>2016-04-02T15:34:24.000Z</published>
    <updated>2016-04-02T15:44:51.205Z</updated>
    
    <content type="html">&lt;p&gt;真假的问题：数据类型-数字(NAN)、字符串、布尔、函数、对象（elem、[]、{}、null）、未定义&lt;br&gt;真:非0的数字、非空字符串、true、函数、能找到的元素、[]、{}&lt;br&gt;假:0、NAN、空的字符串、false、不能找到的元素、null、未定义&lt;/p&gt;
</content>
    
    <summary type="html">
    
      判断真假
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>4.1笔记</title>
    <link href="http://yoursite.com/2016/04/01/4-1%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/01/4-1笔记/</id>
    <published>2016-04-01T15:55:00.000Z</published>
    <updated>2016-04-01T16:00:51.872Z</updated>
    
    <content type="html">&lt;p&gt;运算符有$$,||,!;还有加减乘除和取模&lt;br&gt;反选按钮的操作aInp[0].onclick = function(){for(var i = 1; i&amp;lt; aLi.length;i++){aInp.checked = !aInp[i].checked}}&lt;/p&gt;
</content>
    
    <summary type="html">
    
      运算符，运算流程
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.31笔记</title>
    <link href="http://yoursite.com/2016/04/01/3-31%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/04/01/3-31笔记/</id>
    <published>2016-04-01T15:48:58.000Z</published>
    <updated>2016-04-01T15:51:54.866Z</updated>
    
    <content type="html">&lt;p&gt;函数传参问题，可以先把函数写出来，然后合并相同的函数，可变的部分就是参数。&lt;br&gt;作用域问题，for循环里的函数，不能再用到i；函数里i的值会始终是那个最大值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      函数传参，作用域
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.30笔记</title>
    <link href="http://yoursite.com/2016/03/30/3-30%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/30/3-30笔记/</id>
    <published>2016-03-30T11:33:09.000Z</published>
    <updated>2016-03-30T13:36:15.003Z</updated>
    
    <content type="html">&lt;p&gt;aBtn[i].index = i;添加索引值&lt;br&gt;查找数组元素，可以用arrLi.push( aLi[j] );全放到一个数组后再来用循环做点击事件。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      3.30笔记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.29笔记</title>
    <link href="http://yoursite.com/2016/03/30/3-29%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/30/3-29笔记/</id>
    <published>2016-03-30T11:16:24.000Z</published>
    <updated>2016-03-30T11:20:53.825Z</updated>
    
    <content type="html">&lt;p&gt;js中，图片背景的地址不能做判断&lt;br&gt;颜色值不能做判断&lt;br&gt;相对路径不能zuo’pa判断&lt;br&gt;解决方法：添加一个开关，但是一个开关只能处理一个按钮，但是可以写一个自定义属性aLi[i].Onoff = ‘true’;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      js做判断
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.28笔记</title>
    <link href="http://yoursite.com/2016/03/28/3-28%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/28/3-28笔记/</id>
    <published>2016-03-28T14:47:40.000Z</published>
    <updated>2016-03-28T14:56:29.873Z</updated>
    
    <content type="html">&lt;p&gt;关于选择器的优先级问题，分四个部分，style，id，类，元素以及：子类等，初始为0000；若含有一个id选择器，则改为0100，以此类推，哪个大，哪个的优先级大。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      3.28笔记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.27笔记</title>
    <link href="http://yoursite.com/2016/03/28/3-27%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/28/3-27笔记/</id>
    <published>2016-03-28T14:31:07.000Z</published>
    <updated>2016-03-28T14:42:02.296Z</updated>
    
    <content type="html">&lt;p&gt;计划，两周以内完成.net的相关文件的阅读，每天出去走走，多运动，少躺着。倒计时14天，剩14天。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      3.27笔记
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.26flexbox</title>
    <link href="http://yoursite.com/2016/03/26/3-26flexbox/"/>
    <id>http://yoursite.com/2016/03/26/3-26flexbox/</id>
    <published>2016-03-26T13:28:45.000Z</published>
    <updated>2016-03-26T13:29:52.092Z</updated>
    
    <content type="html">&lt;p&gt;（一） flexbox是什么&lt;br&gt;flex，本意“弹性”。flexbox其实是块元素的一组属性， 就好像display是一组属性， position是一组属性，float也是一组属性。这些概念应该是并列的。&lt;br&gt;flexbox为元素布局提供了更多便利。初来乍到还体会不到它的博大精深，还不了解为什么要把这组属性重点指出来认识一下。&lt;br&gt;这组属性主要包含：&lt;br&gt;(1) 父元属性 flex-direction ，flex-wrap，flex-flow，justify-content，align-items，align-content。或者叫容器属性，这些属性从容器角度决定了内部子元素的布局方式。&lt;br&gt;(2) 子元属性 order,flex-grow,flex-shrink,flex-basis,flex,align-self。这些属性分属于各个子元素（item）,可以实现子元素排序、伸缩等一些布局的变化。&lt;/p&gt;
&lt;p&gt;（二）@media是什么&lt;br&gt;@media 可以针对不同的输出媒体类型（通常是显示器屏幕）设置不同的样式，可以用于实现响应式的页面。例如浏览器大小被重置时，页面也会根据浏览器的宽度和高度重新渲染。&lt;br&gt;常见的媒体类型包括print,screen,speech。&lt;br&gt;常见的媒体功能包括长宽尺寸、长宽比例、分辨率等。task10中用到了minwidth。&lt;/p&gt;
&lt;p&gt;（三）其他&lt;br&gt;拜读其他team的代码，看到同一属性都要写作多行代码。例如：&lt;br&gt;display: -webkit-flex;&lt;br&gt;display: -ms-flexbox;&lt;br&gt;display: flex;&lt;/p&gt;
&lt;p&gt;这应该是考虑到不同浏览器的兼容，不同的前缀符对应于不同的浏览器内核。&lt;/p&gt;
&lt;p&gt;当前浏览器内核引擎基本上是四分天下： Trident: IE 等; Gecko: Firefox 等; WebKit: Safari, Google Chrome,傲游3,猎豹浏览器,百度浏览器等；Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台–Opera mini。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      flexbox
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.25遮罩层的设置</title>
    <link href="http://yoursite.com/2016/03/25/3-25%E9%81%AE%E7%BD%A9%E5%B1%82%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2016/03/25/3-25遮罩层的设置/</id>
    <published>2016-03-25T12:08:39.000Z</published>
    <updated>2016-03-26T12:09:21.601Z</updated>
    
    <content type="html">&lt;p&gt;创建一个div&lt;br&gt;在其下包含三个div&lt;br&gt;第一个不动，后两个设置绝对定位，相对于最外层div，第二个可以和最外层设置一样的宽高，给一个背景色，然后给透明度即可。&lt;br&gt;如果调用js，可以让后两个的display为none，触发点击事件后改为block。&lt;br&gt;关于ie的透明度问题可以选用滤镜&lt;br&gt;一般透明效果：filter:alpha(opacity=30);&lt;br&gt;W3C代码：-webkit-filter:opacity(0.3); 或 opacity:0.3;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      遮罩层
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>3.24call方法</title>
    <link href="http://yoursite.com/2016/03/24/3-24call%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/03/24/3-24call方法/</id>
    <published>2016-03-24T15:33:10.000Z</published>
    <updated>2016-03-24T15:34:03.312Z</updated>
    
    <content type="html">&lt;p&gt;call 方法&lt;br&gt;call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。&lt;br&gt;如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。&lt;br&gt;function add(a,b)&lt;br&gt;{&lt;br&gt;alert(a+b);&lt;br&gt;}&lt;br&gt;function sub(a,b)&lt;br&gt;{&lt;br&gt;alert(a-b);&lt;br&gt;}&lt;br&gt;add.call(sub,3,1);&lt;br&gt;这个例子中的意思就是用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); // 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 &lt;/p&gt;
</content>
    
    <summary type="html">
    
      call方法
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用伪类清除浮动</title>
    <link href="http://yoursite.com/2016/03/24/%E5%88%A9%E7%94%A8%E4%BC%AA%E7%B1%BB%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2016/03/24/利用伪类清除浮动/</id>
    <published>2016-03-23T16:14:04.000Z</published>
    <updated>2016-03-23T16:16:14.022Z</updated>
    
    <content type="html">&lt;p&gt;给要清浮动的父元素加一个clear的类就可以了&lt;br&gt;.clear {zoom:1;}&lt;br&gt;.clear:after { content: ‘’; display: block;clear: both;}&lt;/p&gt;
</content>
    
    <summary type="html">
    
      clear
    
    </summary>
    
    
  </entry>
  
</feed>
